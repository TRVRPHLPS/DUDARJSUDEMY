let options = {
    name: 'Test Object',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function () {
        console.log("Test");

        /* ^ Это способ добавления новых (своих) методов объекту */
    }
};


// Метод перебора объекта через цикл перебора объекта
// И Два способа обращения, первый - к ключам, второй - к значениям

/*
for (let key in options) {
    console.log(`Свойство ${key} имеет значение ${options[key]}`)
}
*/


/*
    Такая конструкция выведет в консоль все пары ключ-значение,
    однако если в объекте вложен ещё один объект, то в консоль
    будет выведено значение object Object
    для того чтобы корректно отработать перебор по объекту
    с корректной отработкой вложенных объектов необходимо
    использовать конструкцию снизу, в ней внутри цикла перебора объекта
    создаётся условие проверки на тип Объект и если значение ключа
    имеет тип объект, то внутрь метода перебора объекта вкладывается
    ещё один метод перебора внутреннего объекта, в нём слово key 
    заменяется на итератор i, вторая часть метода перебора массива
    остаётся без изменений, после чего открываются фигурные скобки
    и в них добавляется команда console.log(любого нужного действия)
    внутрь которой передаётся
    обращение к итератору i, а потом добавляется трёхмерная конструкция
    options[key][i] - которая обозначает обращение к 
    каждому i в каждом key внутри options.

*/


/*
for (let key in options) {
    if (typeof (options[key]) === 'object') {
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`)
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`)
    }
}
*/


/* Более простой пример обращения к трёхмерному объекту,
   без перебора объекта 
  */


//console.log(options["colors"]["border"]); 
//Выведет значение ключа border в объекте colors в объекте options




/* Дальше показан способ подсчитать количество элментов внутри объекта,
   В этом способе мы создаём счётчик counter и добавляем к нему еденицу
   После каждого успешного обращения к паре ключ-значение
   (Включая подсчёт пар вложенных объектов) 
   (а чтобы посчитать только пары верхнего уровня нужно указывать
    counter++ только в нижнем методе перебора объекта)

*/


/*
let counter = 0;

for (let key in options) {
    if (typeof (options[key]) === 'object') {
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
            counter++;
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
        counter++
    }
}
console.log(counter);

*/




/* С помощью следующей конструкции мы можем
   создать массив ключей объекта options */

//console.log(Object.keys(options));


// А так мы ещё и смотрим длину (Ибо это уже массив)
//console.log(Object.keys(options).length); 




//Отдельный блок - Деструктуризация объектов

/* Мы создаём переменную через ключевое слово const или let
   после чего открываем фигурные скобки и через запятую
   указываем те ключи, которые хотим деструктуризировать,
   после чего ставим знак присваивания и обращаемся к тому объекту
   пары ключ-значения которого мы хотим деструктуризировать.
   На выходе получаем обычные переменные с такими названиями,
   как были у ключей и такими значениями, как были у значений.

*/

//const { border, bg } = options.colors;

//console.log(border);