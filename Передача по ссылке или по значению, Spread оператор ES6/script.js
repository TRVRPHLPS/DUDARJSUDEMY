/* Если мы создаём первую переменную и даём ей значение,
   а потом создаём вторую переменную и уравниваем её с первой,
   то в случае если это простой тип данных, то вторая переменная,
   будет создана как отдельная сущность с таким же значением,
   как у первой и если в дальнейшем мы изменим вторую переменную,
   то значение внутри неё изменится, а значение внутри первой
   переменной останется без изменений, однако если сделать тоже
   самое для переменных, значениями которых являются сложные объекты,
   то вместо копирования и создания второй переменной с таким же значением,
   во вторую переменную будет вложена ссылка на первую и тогда в случае
   изменения / присваивания нового значения второй переменной
   изменится также и первая. В первом случае это называется передача по значению,
   а во втором передача по ссылке.
   */

/*
let a = 5,
    b = a;// Здесь кладётся значение

b = b + 5;


// b - будет изменено, а - останется без изменений
console.log(b);
console.log(a);

const obj = {
    a: 5,
    b: 1
};


const copy = obj; // Здесь кладётся ссылка на объект


copy.a = 10;

//оба значения будут изменены
console.log(copy);
console.log(obj);

*/



/*Эта злоебучая конструкция позволяет добится такого же поведения,
  для сложных объектов, как для простых. Проще говоря в таком
  вариенте, уже будет создана отдельная копия объекта и при её
  изменении первый объект останется не изменим. А происходит тут следущее:
  Мы создаём функцию, которая принимает в себя одно значение (ОБЪЕКТ),
  после чего внутри функции мы создаём переменную "копияОбъекта",
  и переменную "ключ" - это технические переменные, необходимые для
  работы цикла for in. После этого мы запускаем цикл перебора объекта
  for ("ключ" "в" "основномОбъекте") и внутри этого цикла кажому ключу
  "копияОбъектах[ключ]" присваиваем такое же значение как у "основногоОбъекта[ключ]",
  после чего возвращаем из функции "копиюОбъекта". На выходе получаем
  два отдельных объекта и в случае изменения второго,
  первый останется таким же как был изначально!

*/

function copy(mainObj) {
    let objCopy = {};
    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj[key];
    }

    return objCopy;
}

const numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
};


const newNumbers = copy(numbers);

newNumbers.a = 10;

console.log(newNumbers);
console.log(numbers);


/*

ОДНАКО!! Если в изначальный объект был вложен ещё один объект,
то при изменении значений вложенного объекта "копииОбъекта",
изменятся и его значения в "основномОбъекте".

Существет два понятия:
Первое - ПОВЕРХНОСТНАЯ копия объекта
Второе - ГЛУБОКАЯ копия объекта

Поверхностная копия, создаёт копию объекта, но во вложенные объекты кладёт ссылки,
а глубокая копия создаёт копии и для простых и для сложных типов внутри объекта.

*/







/* Метод object.assign принимает два параметра,
   первый объект в который нужно добавить,
   второй - объект который нужно в него добавить
   и создаёт независимую копию первого объекта.
   (не считая вложенные структуры *вложенные объекты,
   там также остается ссылочная передача).
   Этот метод достаёт значения из второго объекта
   и вставляет их в конец первого объекта.
   */


/*

const add = {

    d: 17,
    e: 20

};
console.log(Object.assign(numbers, add));


*/

/* также с помощью него можно быстро создавать независимые копии объектов,
   для этого достаточно просто использовать {} -  пустые фигурные скобки,
   в качестве первого параметра.*/


/*
const clone = Object.assign({}, add);

clone.d = 325;

console.log(add);
console.log(clone);
*/









//Пример подобной работы с массивами




const oldArray = ['a', 'b', 'c'];

// const newArray = oldArray; - если отавить так, то в newArray будет ссылка на oldArray


/* А при такой записи, с помощью метода slice
 мы уже создадим реальную новую копию массива
*/

const newArray = oldArray.slice(); 

/* Соответственно в таком случае значение b изменится только в newArray,
   а в oldArray останется без изменений, поскольку будет создан
   полностью новый объект newArray. */


newArray[1] = 'gubagabagubagaba';

console.log(oldArray);
console.log(newArray);



/* В es6 появился SPREAD-оператор "..." - оператор разворота,
   который может "разворачивать" данные из массива,
   а в es8 он начал корректно работать и с объектами.
   */


/* В данном примере мы используем spread-оператор ...
   для того чтобы "развернуть" массивы video и blogs
   и "вытрусить" из них значения в переменную internet,
   без необходимости использовать циклы, или спецметоды.
*/

const video = ['youtube', 'vimeo', 'rutube'],
    blogs = ['wordpress', 'livejournal', 'blogger'],
    internet = [...video, ...blogs, 'vk', 'facebook'];

console.log(internet);



/* В примере ниже, мы создаём функцию, которая ожидает три параметра
   и выводит их значения в консоль, после чего мы создаём массив num
   из трёх элементов и вызываем функцию log передавая внутрь нащ массив,
   ставя перед ним spread оператор разворота, таким образом в параметры функции
   попадает три наших элемента из массива num и функция успешно отрабатывает.
*/


function log(a, b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

const num = [2, 5, 7];
log(...num);


// Также с помощью spread оператора можно быстро создавать новые копии сложных объектов


//Массивов
const xarray = ['a', 'b'];

const newXarray = [...xarray];

//И объектов
const q = {
    one: 1,
    two: 2
};

const newQ = { ...q };